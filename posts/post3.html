<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Implementación y Operaciones</title>
  <link rel="stylesheet" href="../css/style.css">
</head>
<body>
  <header>
    <h1>Post #3: Implementación y Operaciones Fundamentales</h1>
    <nav><a href="../index.html">Inicio</a></nav>
  </header>
  <main>
    <section>
      <h2>Operaciones</h2>
      <h3>Insertar (put)</h3>
      <p>1) Calcular hash de la clave. 2) Reducir a índice (p. ej. modulo tamaño). 3) Insertar en la posición (encadenamiento o open addressing).</p>

      <h3>Buscar (get)</h3>
      <p>Calcular índice y buscar en la lista (chaining) o seguir la secuencia de probes (open addressing) hasta encontrar la clave o una celda vacía.</p>

      <h3>Eliminar (delete)</h3>
      <p>En chaining: eliminar nodo de la lista. En open addressing: marcar celda como &quot;deleted&quot; para preservar la secuencia de probes.</p>

      <h3>Implementación simple en JavaScript (Chaining)</h3>
      <pre class="code">class HashTableChaining {
  constructor(size = 7) {
    this.size = size;
    this.buckets = Array.from({length: size}, () => []);
  }

  _hash(key) {
    let h = 0;
    for (let i = 0; i < key.length; i++) h = (h * 31 + key.charCodeAt(i)) % this.size;
    return h;
  }

  put(key, value) {
    const idx = this._hash(key);
    const bucket = this.buckets[idx];
    const existing = bucket.find(p => p[0] === key);
    if (existing) existing[1] = value; else bucket.push([key, value]);
  }

  get(key) {
    const idx = this._hash(key);
    const bucket = this.buckets[idx];
    const found = bucket.find(p => p[0] === key);
    return found ? found[1] : undefined;
  }

  delete(key) {
    const idx = this._hash(key);
    const bucket = this.buckets[idx];
    const i = bucket.findIndex(p => p[0] === key);
    if (i >= 0) bucket.splice(i, 1);
  }
}

// Ejemplo
const ht = new HashTableChaining(5);
ht.put('a', 1);
ht.put('b', 2);
ht.put('c', 3);
console.log(ht.get('b'));// 2
ht.delete('b');
console.log(ht.get('b'));// undefined
</pre>

      <h3>Open Addressing (Linear Probing) — notas</h3>
      <p>Se necesita una marca especial para celda eliminada. Método de búsqueda debe continuar al encontrar marcas &quot;deleted&quot;.</p>

      <h3>Ejemplo visual: insertar 3 claves, buscar y eliminar</h3>
      <svg class="diagram" viewBox="0 0 700 180" xmlns="http://www.w3.org/2000/svg">
        <g font-family="Arial" font-size="12">
          <g fill="#f3f6ff" stroke="#cfe0ff">
            <rect x="80" y="30" width="80" height="30" />
            <rect x="170" y="30" width="80" height="30" />
            <rect x="260" y="30" width="80" height="30" />
            <rect x="350" y="30" width="80" height="30" />
            <rect x="440" y="30" width="80" height="30" />
          </g>
          <text x="100" y="52">0</text>
          <text x="190" y="52">1</text>
          <text x="280" y="52">2</text>
          <text x="370" y="52">3</text>
          <text x="460" y="52">4</text>

          <text x="95" y="100">insert 'cat' -> idx 2</text>
          <text x="185" y="100">insert 'dog' -> idx 4</text>
          <text x="275" y="100">insert 'cow' -> idx 2 (colisión) -> chaining o probe</text>
        </g>
      </svg>

    </section>
  </main>
  <footer><a href="../index.html">Volver</a></footer>
</body>
</html>
