<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Implementaci√≥n y Operaciones</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <nav class="main-nav">
    <a href="../index.html">‚Üê Inicio</a>
    <a href="post1.html">Introducci√≥n</a>
    <a href="post2.html">Manejo de Colisiones</a>
    <a href="post3.html">Implementaci√≥n</a>
  </nav>

  <header class="post-header"><h1>Post #3: Implementaci√≥n y Operaciones Fundamentales</h1></header>
  <main>
    <section>
      <h2>Operaciones clave en Tablas Hash</h2>
      <p>Las tablas hash soportan principalmente tres operaciones: insertar, buscar y eliminar. Su eficiencia depende de una buena funci√≥n hash y una estrategia de colisi√≥n adecuada.</p>

      <h3>üîπ Insertar (put)</h3>
      <p>Para a√±adir un par clave-valor, el proceso es:</p>
      <ol>
        <li><strong>Calcular el hash:</strong> Se aplica la funci√≥n hash a la clave para obtener un valor num√©rico.</li>
        <li><strong>Obtener el √≠ndice:</strong> Se usa el operador m√≥dulo (`%`) sobre el hash con el tama√±o del arreglo para asegurar que el √≠ndice est√© dentro de los l√≠mites.</li>
        <li><strong>Almacenar el dato:</strong> Se inserta el par clave-valor en la posici√≥n calculada. Si hay una colisi√≥n, se aplica la estrategia elegida (encadenamiento o direccionamiento abierto).</li>
      </ol>
      <pre class="code">
function put(key, value) {
  const hash = calculateHash(key);
  const index = hash % array.length;
  // ... manejar colisi√≥n y almacenar {key, value} en el √≠ndice
}
      </pre>

      <h3>üîπ Buscar (get)</h3>
      <p>Para recuperar un valor a partir de su clave:</p>
      <ol>
        <li><strong>Calcular hash e √≠ndice:</strong> Se repiten los mismos pasos que en la inserci√≥n para encontrar el √≠ndice potencial.</li>
        <li><strong>Localizar el valor:</strong>
          <ul>
            <li>En <strong>encadenamiento</strong>, se recorre la lista enlazada en ese √≠ndice hasta encontrar la clave.</li>
            <li>En <strong>direccionamiento abierto</strong>, se sigue la secuencia de sondeo (lineal, cuadr√°tico, etc.) hasta encontrar la clave o una celda vac√≠a.</li>
          </ul>
        </li>
      </ol>
      <pre class="code">
function get(key) {
  const hash = calculateHash(key);
  const index = hash % array.length;
  // ... buscar la clave en el √≠ndice, siguiendo la estrategia de colisi√≥n
  // y devolver el valor asociado.
}
      </pre>

      <h3>üîπ Eliminar (delete)</h3>
      <p>El borrado var√≠a significativamente seg√∫n la estrategia de colisi√≥n.</p>
      
      <h4>En Encadenamiento (Chaining)</h4>
      <p>Es un proceso directo: se busca el nodo en la lista enlazada del √≠ndice correspondiente y se elimina, como en cualquier lista enlazada est√°ndar.</p>

      <h4>En Direccionamiento Abierto (Open Addressing)</h4>
      <p>No se puede simplemente vaciar la celda, ya que romper√≠a la secuencia de sondeo para otras claves. En su lugar, la celda se marca con un estado especial (ej. "deleted" o "tombstone").</p>
      <p>Durante la b√∫squeda, estas celdas marcadas se tratan como ocupadas para no interrumpir la cadena, pero en la inserci√≥n, se pueden reutilizar para almacenar un nuevo valor.</p>

    </section>
  </main>
  <footer>
    <p>Proyecto acad√©mico ‚Äî Estructura de Datos: Tablas Hash</p>
  </footer>
</body>
</html>